// ============================================================================
// Search Analytics Query - Dynamic JSON Flattening (4 levels)
// ============================================================================
// Purpose: Extract and flatten search analytics data from Application Insights
//          customEvents table with dynamic column generation.
//
// Data Structure (4 nesting levels):
//   Level 1 - customDimensions → contains CustomProps (typically the only key)
//   Level 2 - CustomProps sub-objects and flat values:
//     deviceType (flat), searchQuery, searchPerformance,
//     searchResultsInteraction, userDetails (nested objects)
//   Level 3 - Sub-object fields:
//     searchQuery: { queryText, queryLanguage, queryLengthChars, queryLengthWords }
//     searchPerformance: { searchLatency, searchAccuracy }
//     searchResultsInteraction: { clickedTAB, appliedFilter, clickedResult,
//                                 clickedPosition, totalResultCount }
//     userDetails: { department, jobTitle, location }
//   Level 4 - Deeply nested fields (varies by event type):
//     searchResultsInteraction.totalResultCount: { totalResultCount, newsResultCount, ... }
//     searchResultsInteraction.clickedResult: { resultTitle, resultUrl }
//
// Output: All keys become columns dynamically.
//   - Level 2 flat:  CP_key (e.g. CP_deviceType)
//   - Level 3:       CP_parent_child (e.g. CP_searchQuery_queryText)
//   - Level 4:       CP_parent_child_grandchild (e.g. CP_searchResultsInteraction_totalResultCount_totalResultCount)
//
// NOTE: Some fields appear at different levels depending on event type:
//   - SEARCH_TRIGGERED: queryText is flat at Level 2 → CP_queryText
//   - Other events: queryText is nested in searchQuery → CP_searchQuery_queryText
//
// HOW TO USE: Copy from "set truncationmaxrecords" to "order by"
//
// NOTE: 'timestamp [UTC]' is formatted as 'dd/MM/yyyy HH:mm:ss.fffffff' to preserve
//       millisecond precision for CSV export (Excel truncates the native format).
// ============================================================================


// === COPY FROM HERE ===
set truncationmaxrecords = 500000;
let TimeRange = 90d;
let CustomPropsPrefix = "CP_";
let SearchData = customEvents
    | where timestamp >= ago(TimeRange)
    | where name startswith "Search" or name has "SEARCH"
    | extend cd = todynamic(customDimensions)
    | serialize
    | extend rowId = row_number()
    // --- Level 1: Separate CustomProps from top-level customDimensions ---
    | extend CustomPropsRaw = tostring(cd.CustomProps)
    | extend CP = iff(isnotempty(CustomPropsRaw) and CustomPropsRaw startswith "{", todynamic(CustomPropsRaw), dynamic({}))
    | extend mainBag = bag_remove_keys(cd, dynamic(["CustomProps"]))
    // --- Level 2: Expand CustomProps keys ---
    | extend cpKeys = bag_keys(CP)
    | extend cpKeys = iff(array_length(cpKeys) == 0, dynamic(["__no_cp__"]), cpKeys)
    | mv-expand cpKey = cpKeys to typeof(string)
    | extend cpValue = tostring(CP[cpKey])
    // --- Level 3: Check if CP values contain nested JSON objects ---
    | extend isNestedL3 = cpKey != "__no_cp__" and isnotempty(cpValue) and cpValue startswith "{"
    | extend L3Bag = iff(isNestedL3, coalesce(todynamic(cpValue), dynamic({})), dynamic({}))
    | extend subKeys = bag_keys(L3Bag)
    | extend subKeys = iff(array_length(subKeys) == 0, dynamic(["__no_sub__"]), subKeys)
    | mv-expand subKey = subKeys to typeof(string)
    | extend subValue = iff(subKey != "__no_sub__", tostring(L3Bag[subKey]), "")
    // --- Level 4: Check if Level 3 values contain nested JSON objects ---
    | extend isNestedL4 = subKey != "__no_sub__" and isnotempty(subValue) and subValue startswith "{"
    | extend L4Bag = iff(isNestedL4, coalesce(todynamic(subValue), dynamic({})), dynamic({}))
    | extend subSubKeys = bag_keys(L4Bag)
    | extend subSubKeys = iff(array_length(subSubKeys) == 0, dynamic(["__no_subsub__"]), subSubKeys)
    | mv-expand subSubKey = subSubKeys to typeof(string)
    // --- Build flattened key-value pairs ---
    // Flat CP value (L2):       CP_key → value
    // Nested L3 value:          CP_key_subKey → value
    // Nested L4 value:          CP_key_subKey_subSubKey → value
    // Fallback:                 if nested but empty/unparseable, keep raw value
    | extend kvBag = case(
        cpKey == "__no_cp__", dynamic({}),
        not(isNestedL3), pack(strcat(CustomPropsPrefix, cpKey), cpValue),
        subKey == "__no_sub__", pack(strcat(CustomPropsPrefix, cpKey), cpValue),
        not(isNestedL4), pack(strcat(CustomPropsPrefix, cpKey, "_", subKey), subValue),
        subSubKey == "__no_subsub__", pack(strcat(CustomPropsPrefix, cpKey, "_", subKey), subValue),
        pack(strcat(CustomPropsPrefix, cpKey, "_", subKey, "_", subSubKey), tostring(L4Bag[subSubKey]))
      )
    // --- Reaggregate back to one row per event ---
    | summarize take_any(timestamp), take_any(name), take_any(client_CountryOrRegion), take_any(user_Id), take_any(session_Id), take_any(mainBag), merged = make_bag(kvBag) by rowId
    | extend finalBag = bag_merge(mainBag, coalesce(merged, dynamic({})));
SearchData
| evaluate bag_unpack(finalBag)
| project-away rowId, mainBag, merged
| extend ['timestamp [UTC]'] = format_datetime(timestamp, 'dd/MM/yyyy HH:mm:ss.fffffff')
| project-away timestamp
| project-reorder ['timestamp [UTC]'], name, client_CountryOrRegion, user_Id, session_Id
| order by ['timestamp [UTC]'] desc
// === COPY TO HERE ===


// ============================================================================
// ALTERNATIVE QUERIES (copy/paste separately)
// ============================================================================

// --- QUERY A: Row-based output (keys as rows instead of columns) ---
// customEvents | where timestamp >= ago(24h) | where name startswith "Search" | extend cd = todynamic(customDimensions) | serialize | extend rowId = row_number() | extend CP = todynamic(tostring(cd.CustomProps)) | extend mainBag = bag_remove_keys(cd, dynamic(["CustomProps"])) | mv-expand kind=array mainKV = mainBag | extend PropertyKey = tostring(mainKV[0]), PropertyValue = tostring(mainKV[1]) | project timestamp, name, rowId, PropertyKey, PropertyValue, Source = "main"

// --- QUERY B: Key discovery - find all unique keys ---
// customEvents | where timestamp >= ago(24h) | where name startswith "Search" | extend cd = todynamic(customDimensions) | extend CP = todynamic(tostring(cd.CustomProps)) | extend mainKeys = bag_keys(bag_remove_keys(cd, dynamic(["CustomProps"]))) | mv-expand mainKey = mainKeys to typeof(string) | summarize KeyCount = count(), SampleValue = take_any(tostring(cd[mainKey])) by Key = mainKey | order by KeyCount desc

// --- QUERY C: Simplified version (no CP_ prefix) ---
// customEvents | where timestamp >= ago(24h) | where name startswith "Search" | extend cd = todynamic(customDimensions) | extend CP = todynamic(tostring(cd.CustomProps)) | extend flatBag = bag_merge(bag_remove_keys(cd, dynamic(["CustomProps"])), coalesce(CP, dynamic({}))) | evaluate bag_unpack(flatBag) | project-reorder timestamp, name | order by timestamp desc
